This is my personal FPS, i'm building the idea while studying three.js here i will write the steps of my implementation:

1.
I created the scene, camera, renderer, mesh, meshFloor, Player object and the movement.
The scene has been created with the classical method of three.js, i used then perspective camera that i let it point
to the Mesh (for now is a cube with wireframe: true) but standing in y at player,height with:
    // Move the camera to 0,player.height,-5 (the Y axis is "up")
    camera.position.set(0, player.height, -5);

    // Point the camera to look at 0,player.height,0
    camera.lookAt(new THREE.Vector3(0, player.height, 0));

For the renderer to generate/display my scene i used the WebGLRenderer:
renderer = new THREE.WebGLRenderer({ antialias: true }); // Ensure correct initialization of WebGLRenderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement); // Append renderer's DOM element to the body

To display all: renderer.render(scene, camera);

The meshFloor is the classical plane in three.js:
meshFloor = new THREE.Mesh(
        new THREE.PlaneGeometry(10,10., 10,10), //more segments = more polygons, which results in more detail.
        new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe: true}), //wireframe is useful to see the true geometry of things.
    )
    meshFloor.rotation.x -= Math.PI/2; //rotate the mesh of 90grades x

Then I implemented the movement:
i put eventListener to listen when you press i key and then i changed camera position for W and S in this way, while
for A and D i shift camera rotation.y for a MATH.PI/2 that is 90 grades, im using the radiant for now because trigonometric fun as Math.cos ect in JS are in radiant:
if(keyboard[87]){ // W key
        camera.position.x -= Math.sin(camera.rotation.y) * player.speed;
        camera.position.z -= -Math.cos(camera.rotation.y) * player.speed;
    }
To rotate the camera on player instead:
if(keyboard[37]){ // left arrow key
        camera.rotation.y -= player.turnSpeed;

2.
Turn on shadows in the renderer with shadowMapping used to create shadows by rendering the scene from the perspective of the light source to create a depth map
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.BasicShadowMap;

Replaced MeshBasicMaterial with MeshPhongMaterial

Added an ambient light to the scene

Added a point-light to the scene
light = new THREE.PointLight(0xffffff, 25, 18);
    light.position.set(-3,6,-3);
    light.castShadow = true;
    // Will not light anything closer than 0.1 units or further than 25 units
    light.shadow.camera.near = 0.1;
    light.shadow.camera.far = 25;
    scene.add(light);

3.
Box added with texture, bump and normal maps loaded.
Attach them to a mesh's PhongMaterial.

boxTexture =  textureLoader.load("./textures/crate0/crate0_diffuse.png");
    boxBumpMap = textureLoader.load("textures/crate0/crate0_bump.png");
    boxNormalMap = textureLoader.load("./textures/crate0/crate0_normal.png");

    box = new THREE.Mesh(
        new THREE.BoxGeometry(3, 3, 3),
        new THREE.MeshPhongMaterial({
            color: 0xffffff,
            map: boxTexture,
            bumpMap: boxBumpMap,
            normalMap: boxNormalMap
        })
    );
4.
Add MTLLoader.js and OBJLoader.js


Locate some models


Load model and materials


Add to the scene
5.
create loading scene is an extra, camera, and a mesh.

Create a loadingManager

add LoadingManage to resource loader (texture, MTL, OBJ)

render the loading scene until resource are loaded.
6.
I've separated the models and meshes to save memory. instead of loading and adding OBJ models to the scene we will clone
the models. This way we can have 100 objects all using the same geometry.

create a models index - holds model geometry/material data

create a meshes index- 'instances' of models

rewrite model loading code to load from models index

add a function to run when all resources are loaded like a second init(), function
7.
add .obj and .mtl files to our models index


add a delta timer to the game


clone the model into the mesh in front of the camera


add rhythmic motion to the mesh

8.
create a canShoot variable to delay shoot speed
create a bullets array
create a bullet on spacebar key press
move bullets
clean up bullets when they expire

Shooting Logic:

Within the animate function, it checks if the spacebar (key code 32) is pressed and if player.canShoot is 0 or less.
If true, it creates a new bullet using THREE.Mesh with a sphere geometry and a basic material.
The bullet’s position is set based on the player's weapon position.
The bullet’s velocity is calculated using the sine and cosine of the camera's Y rotation to determine the direction.
The bullet is marked as alive, and a setTimeout is used to remove it from the scene after 1 second.
The bullet is added to the scene and an array bullets, and player.canShoot is set to 20, enforcing a cooldown period before the next shot.

Bullet Update Logic:

Each frame, the animate function also iterates through the bullets array.
For each bullet, if it’s not alive, it’s removed from the array.
If the bullet is alive, its position is updated by adding its velocity.
Additionally, player.canShoot is decremented each frame until it reaches 0, allowing the player to shoot again after 20 frames.

9.
I added the background skyBoxed

10.

added bounding box logic to implement the hitBox. I created a structure object to maintain the bounding boxes that are created
when we add to the scene the cloned meshes after scaled so also the bounding box is scaled.



//FIRST FEEDBACK FROM PROF, TIPS: ADD BOUNCING BULLET WHEN HIT A MESH AND WHAT IN ITALY WE CALL 'CADENZA' BELOW NEW STEPS.



11.
added an invisible capsule bounding box around a given mesh for collision detection. I utilized the capsule geometry and using maths from the scaled mesh"zombie"
I've created a capsule similar to the zombie, we can also give opacity or not to see that.

Also added the GUI addon to change opacity but i've implemented in the addcapsulboundingbox so will not work for nothing else. need to change it

12.
added the zombie movement logic with his capsulboundingbox:
if (meshes["zombie"]) {
        const direction = new THREE.Vector3();
        direction.subVectors(camera.position, meshes["zombie"].position).normalize(); // Calcola la direzione verso la telecamera

        //Setup zombies' velocity
        const speed = 1.6;

        //Update the position of the zombie only on X and Z to let him walk on the Y = 0 (ground)
        meshes["zombie"].position.addScaledVector(new THREE.Vector3(direction.x, 0, direction.z), speed * delta);

        //Update the position of the capsuleBoundingBox only on X and Y
        capsuleBoundingBoxes["zombie"].position.addScaledVector(new THREE.Vector3(direction.x, 0, direction.z), speed * delta);

        //Calculate the rotation to let him look to the camera (player)
        const lookAtPosition = new THREE.Vector3(camera.position.x, meshes["zombie"].position.y, camera.position.z);
        meshes["zombie"].lookAt(lookAtPosition);
    }

13.
Finally when we hit the zombie we get 'zombie' hitted. the problem to fix was to create a Three.box3 setting its dimension with
new THREE.Box3().setFromObject(capsuleBoundingBoxes[key]); after that check the intersection.

14.
i completely changed the capsulBoundingBox structure adding a sub structure zombie that will have a capsuleboundingbox and some hp, for now the mesh is in the meshes structure with all the meshes.

i also implemented the logic to kill the enemy (only the zombie for now):
capsuleBoundingBoxes.zombie[key].hp -= 1;
                    if ((capsuleBoundingBoxes.zombie[key].hp) === 0 ){
                        scene.remove(meshes[key]);
                        scene.remove(capsuleBoundingBoxes.zombie[key].cBBox);


15.
added some GUI functionalities and the collision function player vs meshes.
    need to review it. my decision is to die when zombie touch you.

16.
I put bBox in player object so i changed collision function against meshes



COSA VOGLIO FARE: ZOMBIE CHE SPAWNANO, SUONO PISTOLA, IO CHE TENGO IN MANO LA PISTOLA, ZOMBIE CHE FANNO DANNO QUANDO SONO SU DI ME E LA MIA VITA CHE RESTARTA LA PAGINA
,PROIETTILI RIMBALZANTI, PROIETTILI CON CADENZA, RICARICA PISTOLA,, TERRENO E CASETTA COME IL KING DI 3JS, COMMENTA CON TIPO NUM 1, NUM 2 LE PARTI DEL CODICE
DA FAR VEDERE DURANTE LA PRESENTAZIONE.

