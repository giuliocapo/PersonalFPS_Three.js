This is my personal FPS, i'm building the idea while studying three.js here i will write the steps of my implementation:
THE PR COMMENTS ARE FOR THE PRESENTATION WITH THE SLIDES.

1.
I created the scene, camera, renderer, mesh, meshFloor, Player object and the movement.
The scene has been created with the classical method of three.js, i used then perspective camera that i let it point
to the Mesh (for now is a cube with wireframe: true) but standing in y at player,height with:
    // Move the camera to 0,player.height,-5 (the Y axis is "up")
    camera.position.set(0, player.height, -5);

    // Point the camera to look at 0,player.height,0
    camera.lookAt(new THREE.Vector3(0, player.height, 0));

For the renderer to generate/display my scene i used the WebGLRenderer:
renderer = new THREE.WebGLRenderer({ antialias: true }); // Ensure correct initialization of WebGLRenderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement); // Append renderer's DOM element to the body

To display all: renderer.render(scene, camera);

The meshFloor is the classical plane in three.js:
meshFloor = new THREE.Mesh(
        new THREE.PlaneGeometry(10,10., 10,10), //more segments = more polygons, which results in more detail.
        new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe: true}), //wireframe is useful to see the true geometry of things.
    )
    meshFloor.rotation.x -= Math.PI/2; //rotate the mesh of 90grades x

Then I implemented the movement:
i put eventListener to listen when you press i key and then i changed camera position for W and S in this way, while
for A and D i shift camera rotation.y for a MATH.PI/2 that is 90 grades, im using the radiant for now because trigonometric fun as Math.cos ect in JS are in radiant:
if(keyboard[87]){ // W key
        camera.position.x -= Math.sin(camera.rotation.y) * player.speed;
        camera.position.z -= -Math.cos(camera.rotation.y) * player.speed;
    }
To rotate the camera on player instead:
if(keyboard[37]){ // left arrow key
        camera.rotation.y -= player.turnSpeed;

2.
Turn on shadows in the renderer with shadowMapping used to create shadows by rendering the scene from the perspective of the light source to create a depth map
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.BasicShadowMap;

Replaced MeshBasicMaterial with MeshPhongMaterial

Added an ambient light to the scene

Added a point-light to the scene
light = new THREE.PointLight(0xffffff, 25, 18);
    light.position.set(-3,6,-3);
    light.castShadow = true;
    // Will not light anything closer than 0.1 units or further than 25 units
    light.shadow.camera.near = 0.1;
    light.shadow.camera.far = 25;
    scene.add(light);

3.
Box added with texture, bump and normal maps loaded.
Attach them to a mesh's PhongMaterial.

boxTexture =  textureLoader.load("./textures/crate0/crate0_diffuse.png");
    boxBumpMap = textureLoader.load("textures/crate0/crate0_bump.png");
    boxNormalMap = textureLoader.load("./textures/crate0/crate0_normal.png");

    box = new THREE.Mesh(
        new THREE.BoxGeometry(3, 3, 3),
        new THREE.MeshPhongMaterial({
            color: 0xffffff,
            map: boxTexture,
            bumpMap: boxBumpMap,
            normalMap: boxNormalMap
        })
    );
4.
Add MTLLoader.js and OBJLoader.js


Locate some models


Load model and materials


Add to the scene
5.
create loading scene is an extra, camera, and a mesh.

Create a loadingManager

add LoadingManage to resource loader (texture, MTL, OBJ)

render the loading scene until resource are loaded.
6.
I've separated the models and meshes to save memory. instead of loading and adding OBJ models to the scene we will clone
the models. This way we can have 100 objects all using the same geometry.

create a models index - holds model geometry/material data

create a meshes index- 'instances' of models

rewrite model loading code to load from models index

add a function to run when all resources are loaded like a second init(), function
7.
add .obj and .mtl files to our models index


add a delta timer to the game


clone the model into the mesh in front of the camera


add rhythmic motion to the mesh

8.
create a canShoot variable to delay shoot speed
create a bullets array
create a bullet on spacebar key press
move bullets
clean up bullets when they expire

Shooting Logic:

Within the animate function, it checks if the spacebar (key code 32) is pressed and if player.canShoot is 0 or less.
If true, it creates a new bullet using THREE.Mesh with a sphere geometry and a basic material.
The bullet’s position is set based on the player's weapon position.
The bullet’s velocity is calculated using the sine and cosine of the camera's Y rotation to determine the direction.
The bullet is marked as alive, and a setTimeout is used to remove it from the scene after 1 second.
The bullet is added to the scene and an array bullets, and player.canShoot is set to 20, enforcing a cooldown period before the next shot.

Bullet Update Logic:

Each frame, the animate function also iterates through the bullets array.
For each bullet, if it’s not alive, it’s removed from the array.
If the bullet is alive, its position is updated by adding its velocity.
Additionally, player.canShoot is decremented each frame until it reaches 0, allowing the player to shoot again after 20 frames.

9.
I added the background skyBoxed

10.

added bounding box logic to implement the hitBox. I created a structure object to maintain the bounding boxes that are created
when we add to the scene the cloned meshes after scaled so also the bounding box is scaled.



//FIRST FEEDBACK FROM PROF, TIPS: ADD BOUNCING BULLET WHEN HIT A MESH AND WHAT IN ITALY WE CALL 'CADENZA' BELOW NEW STEPS.



11.
added an invisible capsule bounding box around a given mesh for collision detection. I utilized the capsule geometry and using maths from the scaled mesh"zombie"
I've created a capsule similar to the zombie, we can also give opacity or not to see that.

Also added the GUI addon to change opacity but i've implemented in the addcapsulboundingbox so will not work for nothing else. need to change it

12.
added the zombie movement logic with his capsulboundingbox:
if (meshes["zombie"]) {
        const direction = new THREE.Vector3();
        direction.subVectors(camera.position, meshes["zombie"].position).normalize(); // Calcola la direzione verso la telecamera

        //Setup zombies' velocity
        const speed = 1.6;

        //Update the position of the zombie only on X and Z to let him walk on the Y = 0 (ground)
        meshes["zombie"].position.addScaledVector(new THREE.Vector3(direction.x, 0, direction.z), speed * delta);

        //Update the position of the capsuleBoundingBox only on X and Y
        capsuleBoundingBoxes["zombie"].position.addScaledVector(new THREE.Vector3(direction.x, 0, direction.z), speed * delta);

        //Calculate the rotation to let him look to the camera (player)
        const lookAtPosition = new THREE.Vector3(camera.position.x, meshes["zombie"].position.y, camera.position.z);
        meshes["zombie"].lookAt(lookAtPosition);
    }

13.
Finally when we hit the zombie we get 'zombie' hitted. the problem to fix was to create a Three.box3 setting its dimension with
new THREE.Box3().setFromObject(capsuleBoundingBoxes[key]); after that check the intersection. questo perchè se nn avessi fatto io la capsula
fare la boundingbox diretto sul modello veniva un rettangolone gigante

14.
i completely changed the capsulBoundingBox structure adding a sub structure zombie that will have a capsuleboundingbox and some hp, for now the mesh is in the meshes structure with all the meshes.

i also implemented the logic to kill the enemy (only the zombie for now):
capsuleBoundingBoxes.zombie[key].hp -= 1;
                    if ((capsuleBoundingBoxes.zombie[key].hp) === 0 ){
                        scene.remove(meshes[key]);
                        scene.remove(capsuleBoundingBoxes.zombie[key].cBBox);


15.
added some GUI functionalities and the collision function player vs meshes.
    need to review it. my decision is to die when zombie touch you.

16.
I put bBox in player object so i changed collision function against meshes

17.
I added the creation of zombies as many as I want in the sides of the map,
every zombie is in meshes as all meshes as before but the capsulboundingbox structure is mantained as before.
I also changed the animate() function for the zombie to let all zombie to animate as the first zombie created. also added a cool way to manage
all capsule with a call from main for boundingboxes.

18.
I added collition function for the zombie with meshes and player. just as for the player i've saved last position every time for the capsulebox and the zombie (that
are separated object) and if they have a collision with meshes or player the continue to update their position with the last saved. the capsuleBox is a
capsule geometry then i had to create the box to collide with the zombie in this way:
const zombieMesh = capsuleBoundingBoxes.zombie[key2].cBBox;
const zombieBox = new THREE.Box3().setFromObject(zombieMesh);

19.
I added hp of the player.

20.
added audioLoader.js from which i add ambient audio, shoot audio and also the easter egg audio

21.
I added the bullet cadence (was the same code but adding something on y to let him drop), the UZI marker with css toggle in html

22.
I added in  // Move zombie towards the camera and //Check for bullet collisions with zombies the check if the zombie in that check is different from undefined like
capsuleBoundingBoxes.zombie[key] !== undefined because i added delete capsuleBoundingBoxes.zombie[key]; to unless I continue to hit a 'GHOST' capsule box in that position that blocks
my bullets because it was remaining in the array.


23.
I added the function to let the bullet to bounce when hit ONLY meshes. I used

//function to calculate the reflected vector for collision with the meshes (bounce)
function reflectVector(velocity, normal) {
    return velocity.clone().sub(normal.clone().multiplyScalar(2 * velocity.dot(normal)));
}
and then i calculated the normal to the surface and calculated the new velocity with which the bullet moves.
Added also number of bounces but i will delete it.

24.
I fix some lines for the bullet reflection function, commented the code and deleted the part for "fix amount of bounces",
it's cooler let it bounce 10 times and after 1 sec like all bullet expire and with .splice funcion delete from the bullets array


25.
added the fact that now when the zombie collides player take damage, also added another animation, just need to understand how to import another one.
when zombie hit you you take too much damage, but if he collide with a mesh u take 1 damage, see if you can fix it.

26.
I divided the check of collision of the zombie with the meshes and the player so that now zombie don't hit player running on a block lol.
Also fixed the problem with action, the problem was that there exist a property on the clipanimation that is .isRunning().
!actions.primary.isRunning()

potresti anche risolvere semplicemente dicendo che i zombi che rimangono a ballare sono quelli che se ti rihittano ti fanno piu male, pero boh.
altrimenti potresti mettere che quando ti si mette davanti fa la T pose, tanto quella la fa a prescindere se stoppi


27.
finally zombie hit me, the error was hard to see, i was decrementing hp in two part of the code.
I used currentTime - lastHitTime > 2 secondi to take the other hit from the same zombie.
I also added a CSS banner that i can show up the hp with javascript code on html and call of that function every time i take an hit.

28.
added the death screen when the player died adding also the check on the event listener for key pressing so that when you die
you can't move but you can only click on retry

29.
changed model fbx of Zombie and changed the animation, added also a tertiary animation that is moonwalk at the moment when I die.

30.
added sound of player death and also added the Final boss that is loaded when you kill all the zombies through a
funcion that i make it global initializing a variable global and making that equal to a function loadBoss() defined in init.

31. devi aggiungere la pagina della vittoria quando 'zombie' che sarebbe il boss finale muore che è lo stesso che dire che lo zombie count va a -1.

32.
adjusted meshes like tent and easter egg in the corners of the map. I built the house with all mapping for all textures,
i created an object that is the father that i added into the scene and then all added to that object. The door got Z FIGHTING fixed it.
also changed light, light farm useless right now,
need to refine the shadow because the light is too far so now you can't really see the shadow in a good way, too much pixel.

33.
change light system, added ghost light that is a spotlight

34.
added positionRandomizer.js to clean the code. Also right commented the loadModel function to load all simple meshes from model.

35.
cloned the safe spot using Three.group (original is north-west) in the right corner. the thing.glb has been cloned in the modelLoader.js this because
need to be loaded with loader manager. so it's better like this for performance.

36.
added constraints with graveyard //CONSTRAINTS OF THE MAP.
ZOMBIE NOW spaw out of the graveyard so seems they rebirth lol.
const position = getRandomPositionOnEdge(mapSize + 50); //let the zombie spawn out of the graveyard
also added the exception for the graveyard for the collision with the zombies.
// Skip collision check for GraveFree (graveyard)
if (key.includes('GraveFree')) {
continue;
} so that now u can hit the zombie only when they join "YOUR MAP"

37.
safe spot updating, left the idea of copy the same spot, but creating different spot is cool.

38.
safe spot done for each corner.


39.
added logic for final zombie boss. created a function equal to the the one for the other zombie (LoadAnimatedModelFinalBoss),
also added the funtion to color it when he go RAGE, also this in ModelLoader.js (colorFBXModel). then i created the spotLight above the zombie that
follow him updateFinalBossSpotlight(). Control if he rage and when he is added with two variables var finalBossAdded, var finalBossRaged,
when he is rage so he got 25 hp, in the collision of zombies with models, he start to avoid collisions with models.
Pay attention console.log('Zombie is in rage mode, avoiding all collisions'); launched too many times.

40.
added boss in rage label and doun of deadlyboss WOW, added also the win screen when you kill the final boss

41.
ghost light added, 2 go on the corners to indicate the safe spot the other turn around the house with an y calculated on geogebra.
FAI VEDERE ALL'ESAME:
IO HO PRATICAMENTE TUTTE ANIMATION PER TRASFORMATION.
IMPARA BENE LE FUNZIONI IN TOTALE, CIOè COME FUNZIONA TUTTO IL SISTEMA DI SPARO DA QUANDO CREI LA SFERA MESH E POI CON LA VELOCITA LA SPOSTI FUORI SU ANIMATE
E POI SE HITTI SUCCEDE QUESTO ECC, UGUALE PER GLI ALTRI "SISTEMI" per ripeterla al meglio.

ANIMATION: LOADING SCREEN, PISTOLA INALAZIONE ANIMAZIONE, PROIETTILE CHE PARTE DALLA PISTOLA, CADENZA, RIMBALZI PROIETTILI, SHADOW ECC ECC...

RILEGGI:


COSA VOGLIO FARE: RESTARTA LA PAGINA
RICARICA PISTOLA (lasciando il codice come è adesso potrei inserire una variabile che si "azzera" sparando quando sia azzera non mi fa piu saprare, ricaricando torna "positiva" e posso risparare ) = potrei mettere un altra variabile per i colpi in player e ogni volta che clicco la space bar decremente quando sono a zero non entro nella funzione
per creare i proiettili e devo prima cliccare 'R' che mi fa partire un animazione tipo che ruota sulla linea verticale la pistola davanti a me
come un cerchio di fuoco, si potrebbe fare
COMMENTA CON TIPO NUM 1, NUM 2 LE PARTI DEL CODICE
DA FAR VEDERE DURANTE LA PRESENTAZIONE.

