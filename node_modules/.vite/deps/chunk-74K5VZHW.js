import {
  TempNode_default,
  addNodeClass,
  addNodeElement,
  nodeProxy
} from "./chunk-ROSZ3DPH.js";

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = typeof bNode !== "undefined" ? bNode.build(builder, typeB) : null;
    const outputLength = builder.getTypeLength(output);
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output !== "void") {
      if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output);
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`${a} ${op} ${b}`, type, output);
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var remainder = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var notEqual = nodeProxy(OperatorNode, "!=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var not = nodeProxy(OperatorNode, "!");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitNot = nodeProxy(OperatorNode, "~");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addNodeElement("add", add);
addNodeElement("sub", sub);
addNodeElement("mul", mul);
addNodeElement("div", div);
addNodeElement("remainder", remainder);
addNodeElement("equal", equal);
addNodeElement("notEqual", notEqual);
addNodeElement("lessThan", lessThan);
addNodeElement("greaterThan", greaterThan);
addNodeElement("lessThanEqual", lessThanEqual);
addNodeElement("greaterThanEqual", greaterThanEqual);
addNodeElement("and", and);
addNodeElement("or", or);
addNodeElement("not", not);
addNodeElement("xor", xor);
addNodeElement("bitAnd", bitAnd);
addNodeElement("bitNot", bitNot);
addNodeElement("bitOr", bitOr);
addNodeElement("bitXor", bitXor);
addNodeElement("shiftLeft", shiftLeft);
addNodeElement("shiftRight", shiftRight);
addNodeClass("OperatorNode", OperatorNode);

export {
  OperatorNode_default,
  add,
  sub,
  mul,
  div,
  remainder,
  equal,
  notEqual,
  lessThan,
  greaterThan,
  lessThanEqual,
  greaterThanEqual,
  and,
  or,
  not,
  xor,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  shiftLeft,
  shiftRight
};
//# sourceMappingURL=chunk-74K5VZHW.js.map
